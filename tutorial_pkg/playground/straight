#!/usr/bin/python3
import sys
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import math

# Ros Node process:
def main():
    # Initialize ROS and a ROS node
    rclpy.init(args=sys.argv)
    node = Node('basic_move')

    # Initialize our control:
    control = StraightCtrl(node)  # Pass the node to the constructor

    # infinite Loop:
    rclpy.spin(node)

    # clean end
    node.destroy_node()
    rclpy.shutdown()

# Ros Node Class:
class StraightCtrl:
    def __init__(self, rosNode):
        self.rosNode = rosNode  # Store the rosNode instance
        self.obstacle_left = False
        self.obstacle_right = False
        self.initializeRosNode()

    def initializeRosNode(self):
        # Get logger from the node:
        self._logger = self.rosNode.get_logger()

        # Initialize publisher:
        self._pubVelocity = self.rosNode.create_publisher(
            Twist, '/multi/cmd_nav', 10
        )

        # Initialize scan callback:
        self._subToScan = self.rosNode.create_subscription(
            LaserScan, '/scan',
            self.scan_callback, 10
        )

        # Initialize control callback:
        self._timForCtrl = self.rosNode.create_timer(
            0.05, self.control_callback
        )

    def scan_callback(self, scanMsg):
        self._logger.info('> get scan')
        
        # Define left and right ranges
        left_ranges = []
        right_ranges = []

        # Get angle and range info
        angle_min = scanMsg.angle_min
        angle_max = scanMsg.angle_max
        angle_increment = scanMsg.angle_increment
        num_ranges = len(scanMsg.ranges)

        # Set obstacle detection threshold (10 cm)
        obstacle_threshold = 0.1  # 10 cm
        
        # The angle_middle is calculated as the midpoint of the scan range.
        angle_middle = (angle_min + angle_max)/2  # Zero angle is considered middle (adjust as needed)

        # Separate scan data into left and right sectors based on angle
        for i, range in enumerate(scanMsg.ranges):
            angle = angle_min + i * angle_increment

            # Ignore invalid ranges
            if range <= 0.0 or range == float('inf') or range == float('nan'):
                continue

            # Log the angle and range to help diagnose the issue
            #self._logger.info(f"Angle: {angle:.2f}, Range: {range:.2f}")

            # Left sector: angles from angle_min to 0 (or middle if positive angles)
            if angle <= angle_middle:
                left_ranges.append(range)
            # Right sector: angles from 0 to angle_max
            else:
                right_ranges.append(range)

        # Check for obstacles in the left sector
        if left_ranges and min(left_ranges) < obstacle_threshold:
            self.obstacle_left = True
            self._logger.info('Obstacle detected on the left!')
        else:
            self.obstacle_left = False

        # Check for obstacles in the right sector
        if right_ranges and min(right_ranges) < obstacle_threshold:
            self.obstacle_right = True
            self._logger.info('Obstacle detected on the right!')
        else:
            self.obstacle_right = False

    def control_callback(self):
        self._logger.info('< define control')
        # Create a Twist message
        twist = Twist()
    
        # Check for obstacles and set velocities accordingly
        if not self.obstacle_left and not self.obstacle_right:
            # Move forward if no obstacles on either side
            twist.linear.x = 0.1
            twist.angular.z = 0.0
        elif self.obstacle_left and self.obstacle_right:
            # Move forward if no obstacles on either side
            twist.linear.x = 0.1
            twist.angular.z = 0.0
        elif self.obstacle_left:
            # Turn right if there's an obstacle on the left
            twist.linear.x = 0.1
            twist.angular.z = -0.2
        elif self.obstacle_right:
            # Turn left if there's an obstacle on the right
            twist.linear.x = 0.1
            twist.angular.z = 0.2

        # Publish the velocity command
        self._pubVelocity.publish(twist)

# Go:
if __name__ == '__main__':
    main()
