#!/usr/bin/env python3
import numpy as np
import rclpy
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose
import tf2_ros
from tf2_geometry_msgs import do_transform_pose
import math
import heapq

class MapExplorer:
    def __init__(self):
        self.node = rclpy.create_node('map_explorer')
        # Initialize Transform listener and buffer
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self.node)
        self.local_frame = 'base_link'  # Set the local frame here, e.g., 'base_link'

        # Subscribers and publisher
        self.map_sub = self.node.create_subscription(
            OccupancyGrid, '/map', self.map_callback, 10)
        self.costmap_sub = self.node.create_subscription(
            OccupancyGrid, '/move_base/global_costmap/costmap', self.costmap_callback, 10)
        self._PubGoal = self.node.create_publisher(Pose, '/goal', 10)

        # Initialize data containers
        self.map_data = None
        self.costmap_data = None

        # Define arena boundaries (example values, adjust as needed)
        self.arena_min_x = 0
        self.arena_max_x = 10
        self.arena_min_y = 0
        self.arena_max_y = 10

        # Define maximum distance for goal selection
        self.max_goal_distance = 500.0  # Maximum distance to consider a goal (in meters)

        # Timer to periodically publish goals
        self.node.create_timer(1.0, self.publish_goal)  # Every second

    def map_callback(self, msg):
        self.map_data = np.array(msg.data).reshape(msg.info.height, msg.info.width)
        self.node.get_logger().info(f"Received map data: {self.map_data.shape}")

    def costmap_callback(self, msg):
        self.costmap_data = np.array(msg.data).reshape(msg.info.height, msg.info.width)
        self.node.get_logger().info(f"Received costmap data: {self.costmap_data.shape}")

    def flood_fill(self, i, j, visited):
        """Flood fill algorithm to find all connected unknown cells (-1)."""
        stack = [(i, j)]
        cluster = []
        while stack:
            x, y = stack.pop()
            if (x < 0 or x >= self.map_data.shape[0] or y < 0 or y >= self.map_data.shape[1]):
                continue
            if self.map_data[x, y] != -1 or (x, y) in visited:
                continue
            visited.add((x, y))
            cluster.append((x, y))
            # Check the 4 neighboring cells (up, down, left, right)
            stack.append((x - 1, y))
            stack.append((x + 1, y))
            stack.append((x, y - 1))
            stack.append((x, y + 1))
        return cluster

    def find_largest_unknown_cluster(self):
        """Find the largest cluster of unknown cells (-1)."""
        if self.map_data is None:
            self.node.get_logger().warn("Map data not received yet!")
            return None

        visited = set()
        clusters = []
        for i in range(1, self.map_data.shape[0] - 1):
            for j in range(1, self.map_data.shape[1] - 1):
                if self.map_data[i, j] == -1 and (i, j) not in visited:
                    cluster = self.flood_fill(i, j, visited)
                    if cluster:
                        clusters.append(cluster)

        if clusters:
            self.node.get_logger().info(f"Found {len(clusters)} clusters of unknown cells.")
            # Find the largest cluster
            largest_cluster = max(clusters, key=len)
            self.node.get_logger().info(f"Largest cluster has {len(largest_cluster)} cells.")
            return largest_cluster
        else:
            self.node.get_logger().info("No unknown regions (clusters) found.")
            return None

    def get_goal_in_cluster(self, cluster):
        """Select a goal position in the largest cluster (e.g., center of the cluster)."""
        if not cluster:
            self.node.get_logger().warn("Cluster is empty, no goal can be selected.")
            return None
        # Choose the center of mass of the cluster as the goal position
        cluster_array = np.array(cluster)
        center_x = int(np.mean(cluster_array[:, 0]))
        center_y = int(np.mean(cluster_array[:, 1]))
        return center_x, center_y

    def is_within_arena(self, x, y):
        """Check if the given coordinates are within the defined arena boundaries."""
        return self.arena_min_x <= x <= self.arena_max_x and self.arena_min_y <= y <= self.arena_max_y

    def is_safe_distance(self, goal_x, goal_y, safe_distance=3):
        """Check if the goal is a safe distance away from obstacles."""
        if self.costmap_data is None:
            return False

        for di in range(-safe_distance, safe_distance + 1):
            for dj in range(-safe_distance, safe_distance + 1):
                x, y = goal_x + di, goal_y + dj
                if 0 <= x < self.costmap_data.shape[0] and 0 <= y < self.costmap_data.shape[1]:
                    if self.costmap_data[x, y] == 100:  # If there's an obstacle
                        return False
        return True

    def a_star(self, start, goal):
        """A* pathfinding algorithm to find a path from start to goal."""
        def heuristic(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1])

        open_set = []
        heapq.heappush(open_set, (0, start))
        came_from = {}
        g_score = {start: 0}
        f_score = {start: heuristic(start, goal)}

        while open_set:
            _, current = heapq.heappop(open_set)

            if current == goal:
                path = []
                while current in came_from:
                    path.append(current)
                    current = came_from[current]
                path.reverse()
                return path

            for neighbor in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                neighbor = (current[0] + neighbor[0], current[1] + neighbor[1])
                tentative_g_score = g_score[current] + 1

                if 0 <= neighbor[0] < self.map_data.shape[0] and 0 <= neighbor[1] < self.map_data.shape[1]:
                    if self.map_data[neighbor[0], neighbor[1]] == 100 or self.costmap_data[neighbor[0], neighbor[1]] == 100:
                        continue

                    if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                        came_from[neighbor] = current
                        g_score[neighbor] = tentative_g_score
                        f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
                        heapq.heappush(open_set, (f_score[neighbor], neighbor))

        return None

    def publish_goal(self):
        # Get the robot's current position
        try:
            transform = self.tf_buffer.lookup_transform('map', self.local_frame, rclpy.time.Time())
            robot_x = int(transform.transform.translation.x)
            robot_y = int(transform.transform.translation.y)
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException) as e:
            self.node.get_logger().warn("Error getting transform: " + str(e))
            return

        # Ensure map_data and costmap_data are not None
        if self.map_data is None or self.costmap_data is None:
            self.node.get_logger().warn("Map data or costmap data not received yet!")
            return

        # Find the largest unexplored cluster
        largest_cluster = self.find_largest_unknown_cluster()
        if largest_cluster:
            # Get a goal in the largest cluster
            goal_x, goal_y = self.get_goal_in_cluster(largest_cluster)
            if goal_x is not None and goal_y is not None:
                # Calculate the distance to the goal
                distance_to_goal = math.sqrt((goal_x - robot_x) ** 2 + (goal_y - robot_y) ** 2)
                self.node.get_logger().info(f"Distance to goal: {distance_to_goal} meters")
                if distance_to_goal <= self.max_goal_distance:
                    if True:
                        # Use A* to find a path to the goal
                        path = self.a_star((robot_x, robot_y), (goal_x, goal_y))
                        if path:
                            self.node.get_logger().info(f"Publishing goal at: x={goal_x}, y={goal_y}")
                            goal_pose = Pose()
                            goal_pose.position.x = float(goal_x)
                            goal_pose.position.y = float(goal_y)

                            # Get the current time for transformations
                            current_time = self.node.get_clock().now().to_msg()

                            try:
                                # Use the latest available transform instead of a specific time
                                stamped_transform = self.tf_buffer.lookup_transform(
                                    self.local_frame, 'map', rclpy.time.Time())  # Use current time to get the latest transform

                                self.node.get_logger().info(f"Found transform: {stamped_transform}")

                                # Transform the goal from the global frame (map) to the local frame
                                local_goal = do_transform_pose(goal_pose, stamped_transform)

                                # Publish or use the transformed local goal
                                self._PubGoal.publish(local_goal)
                                self.node.get_logger().info(f"Published goal: {local_goal}")
                            except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException) as e:
                                self.node.get_logger().error(f"Transform failed: {e}")
                        else:
                            self.node.get_logger().warn(f"No valid path found to goal ({goal_x}, {goal_y}).")
                    else:
                        self.node.get_logger().warn(f"Goal ({goal_x}, {goal_y}) is either outside the arena boundaries or too close to obstacles.")
                else:
                    self.node.get_logger().warn(f"Goal ({goal_x}, {goal_y}) is too far from the robot (distance: {distance_to_goal} meters).")
            else:
                self.node.get_logger().info("No valid goal found!")
        else:
            self.node.get_logger().info("No unexplored areas found!")

def main():
    rclpy.init()
    map_explorer = MapExplorer()

    # Spin the node to keep it running
    rclpy.spin(map_explorer.node)

    # Clean up and shutdown
    map_explorer.node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()