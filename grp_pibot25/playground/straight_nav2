#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from geometry_msgs.msg import Pose
from nav2_msgs.action import NavigateToPose
from kobuki_ros_interfaces.msg import BumperEvent, WheelDropEvent, ButtonEvent, Sound
import tf2_ros

class Nav2Navigator(Node):
    def __init__(self):
        super().__init__('nav2_navigator')

        self.current_goal_handle = None
        self.navigating = False  # Are we currently navigating?
        self.pending_goal = None # Store the last received goal if we are busy
        self.is_bumped = False

        # -------------------------
        #  ROS Setup
        # -------------------------
        # Action client to Nav2's NavigateToPose
        self._nav_to_pose_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')

        # Subscribe to a /goal topic carrying a simple Pose (from RRTExplorer or another node)
        self.goal_sub = self.create_subscription(
            Pose, '/goal', self.goal_callback, 10
        )

        # Optional bumper & wheel drop to stop or cancel navigation
        self.bumper_sub = self.create_subscription(
            BumperEvent, '/events/bumper', self.bumper_callback, 10
        )
        self.wheeldrop_sub = self.create_subscription(
            WheelDropEvent, '/events/wheel_drop', self.wheeldrop_callback, 10
        )
        self.button_sub = self.create_subscription(
            ButtonEvent, '/events/button', self.button_callback, 10
        )

        # (Optional) Sound feedback
        self.sound_pub = self.create_publisher(
            Sound, '/commands/sound', 10
        )

        # TF buffer/listener (if you need to validate or transform the goal)
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)

        self.get_logger().info("Nav2Navigator node initialized.")

    # --------------------------------------------------------------------------
    #   Goal Callback
    # --------------------------------------------------------------------------
    def goal_callback(self, msg: Pose):
        """
        If we're currently navigating to a goal, store this new one as pending.
        Otherwise, send it to Nav2 right away.
        """
        self.get_logger().info(
            f"New goal received: x={msg.position.x:.2f}, y={msg.position.y:.2f}"
        )

        if self.navigating:
            # We already have a goal in progress, so store this as the latest pending goal
            self.get_logger().info(
                "Currently navigating, so saving this new goal as pending."
            )
            self.pending_goal = msg
        else:
            # We are free to navigate immediately
            self.send_goal_to_nav2(msg)

    def send_goal_to_nav2(self, pose_msg: Pose):
        """
        Helper function to send the given Pose to Nav2's NavigateToPose action client.
        """
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.pose = pose_msg
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()

        # Wait for the action server
        self._nav_to_pose_client.wait_for_server()

        self.navigating = True  # mark that we are now navigating
        self.get_logger().info(
            f"Sending goal to Nav2: x={pose_msg.position.x:.2f}, y={pose_msg.position.y:.2f}"
        )

        # Send the goal
        send_goal_future = self._nav_to_pose_client.send_goal_async(
            goal_msg, feedback_callback=self.feedback_callback
        )
        send_goal_future.add_done_callback(self.goal_response_callback)

    # --------------------------------------------------------------------------
    #   Goal Response and Result
    # --------------------------------------------------------------------------
    def goal_response_callback(self, future):
        """
        Called once Nav2 has accepted or rejected the goal.
        """
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().warn('Goal rejected by Nav2.')
            self.navigating = False
            # Possibly check if there's a pending goal
            self.check_for_pending_goal()
            return

        self.get_logger().info('Goal accepted by Nav2.')
        self.current_goal_handle = goal_handle
        self._result_future = goal_handle.get_result_async()
        self._result_future.add_done_callback(self.result_callback)

    def result_callback(self, future):
        """
        Called when Nav2 finishes navigating to the goal (success, failure, or canceled).
        """
        result = None
        try:
            result = future.result().result
        except Exception as e:
            self.get_logger().error(f"Exception getting result: {str(e)}")

        if result:
            self.get_logger().info("Goal reached successfully!")
        else:
            self.get_logger().info("Navigation action failed or was canceled.")

        # Clear the current navigation state
        self.navigating = False
        self.current_goal_handle = None

        # Check if there's a newer goal pending
        self.check_for_pending_goal()

    # --------------------------------------------------------------------------
    #   Pending Goal Logic
    # --------------------------------------------------------------------------
    def check_for_pending_goal(self):
        """
        If there's a pending goal that arrived while we were navigating,
        send it now that we're free.
        """
        if self.pending_goal is not None:
            latest_goal = self.pending_goal
            self.pending_goal = None
            self.get_logger().info("Sending previously pending goal.")
            self.send_goal_to_nav2(latest_goal)

    # --------------------------------------------------------------------------
    #   Feedback
    # --------------------------------------------------------------------------
    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        x = feedback.current_pose.pose.position.x
        y = feedback.current_pose.pose.position.y
        # self.get_logger().info(f'Current robot position: x={x:.2f}, y={y:.2f}')

    # --------------------------------------------------------------------------
    #   Bumper, WheelDrop, and Button
    # --------------------------------------------------------------------------
    def bumper_callback(self, msg: BumperEvent):
        """Handle bumper events."""
        if msg.state == BumperEvent.PRESSED:
            self.is_bumped = True
            self.get_logger().info("Bumper pressed!")
            if self.current_goal_handle:
                self.current_goal_handle.cancel_goal_async()
        else:
            self.is_bumped = False

    def wheeldrop_callback(self, msg: WheelDropEvent):
        """Handle wheel drop events."""
        if msg.state == WheelDropEvent.DROPPED:
            self.is_bumped = True
            self.get_logger().info("Wheel dropped!")
            if self.current_goal_handle:
                self.current_goal_handle.cancel_goal_async()
        else:
            self.is_bumped = False

    def button_callback(self, msg: ButtonEvent):
        """Handle button events."""
        if msg.state == ButtonEvent.PRESSED:
            self.get_logger().info(f"Button {msg.button} pressed!")

def main(args=None):
    rclpy.init(args=args)
    node = Nav2Navigator()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
