#!/usr/bin/python3
import sys
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist, Pose
from kobuki_ros_interfaces.msg import BumperEvent  # type: ignore
from kobuki_ros_interfaces.msg import WheelDropEvent  # type: ignore
from kobuki_ros_interfaces.msg import ButtonEvent  # type: ignore
from kobuki_ros_interfaces.msg import Sound  # type: ignore
import math
import time
import tf2_ros
from geometry_msgs.msg import TransformStamped
import random


# ROS Node process:
def main():
    rclpy.init(args=sys.argv)
    node = Node('basic_move')

    # Initialize control class with an initial goal
    control = StraightCtrl(node, goal_x=5.0, goal_y=5.0)  # Example goal: (5.0, 5.0)

    # Infinite loop for ROS to keep running
    rclpy.spin(node)

    # Clean up
    node.destroy_node()
    rclpy.shutdown()


# ROS Node Class:
class StraightCtrl:
    def __init__(self, rosNode, goal_x, goal_y):
        self.rosNode = rosNode  # Store the rosNode instance
        self.goal_x = goal_x  # Initial goal x coordinate
        self.goal_y = goal_y  # Initial goal y coordinate
        self.obstacle_left = False
        self.obstacle_right = False
        self.obstacle_front = False
        self.bumped = False
        self.highSpeed = False
        self.midSpeed = False
        self.counter = 0
        self.turnRight = False
        self.turnLeft = False
        self.last_linear_x = 0.0  # Track last linear velocity for smooth transition
        self.last_angular_z = 0.0  # Track last angular velocity for smooth transition

        self.max_linear_speed = 0.8  # Max forward speed (m/s)
        self.max_angular_speed = 2.0  # Max angular speed (rad/s)
        self.acceleration = 0.1  # Rate of acceleration
        self.decceleration = 0.25  # Rate of decceleration
        self.angleAcceleration = 0.3  # Rate of acceleration for angular velocity
        self.initializeRosNode()

        # Initialize tf listener
        self.tf_buffer = tf2_ros.Buffer()
        self.listener = tf2_ros.TransformListener(self.tf_buffer, rosNode)

        # Subscribe to goal position updates
        self._subToGoal = self.rosNode.create_subscription(
            Pose, '/goal', self.update_goal_callback, 10
        )

    def initializeRosNode(self):
        # Initialize subscribers and publishers
        self._subToDetection = self.rosNode.create_subscription(
            String, '/detection',
            self.detection_callback, 10
        )
        # Get logger from the node:
        self._logger = self.rosNode.get_logger()

        self._subToBumper = self.rosNode.create_subscription(
            BumperEvent, '/events/bumper',
            self.bumper_callback, 10
        )

        self._subToWheeldrop = self.rosNode.create_subscription(
            WheelDropEvent, '/events/wheel_drop',
            self.wheeldrop_callback, 10
        )

        self._subToButtons = self.rosNode.create_subscription(
            ButtonEvent, '/events/button',
            self.button_callback, 10
        )

        self._pubSound = self.rosNode.create_publisher(
            Sound, '/commands/sound',
            10
        )

        self._pubVelocity = self.rosNode.create_publisher(
            Twist, '/multi/cmd_nav', 10
        )

        self._subToScan = self.rosNode.create_subscription(
            LaserScan, '/scan',
            self.scan_callback, 10
        )

        self._subToGoal = self.rosNode.create_subscription(
            Pose, '/goal', self.update_goal_callback, 10
        )

        self._timForCtrl = self.rosNode.create_timer(
            0.1, self.control_callback  # Increased time for smoother updates
        )

    def update_goal_callback(self, msg):
        """Callback to update the goal position dynamically."""
        self.goal_x = msg.position.x
        self.goal_y = msg.position.y
        self._logger.info(f"Goal updated to: ({self.goal_x}, {self.goal_y})")

    def detection_callback(self, msg):
        # self._logger.info(f'Detection event received: {msg.data}')
        self._pubSound.publish(Sound(value=Sound.CLEANINGEND))

    def bumper_callback(self, msg):
        self._logger.info(f'Bumper event received: {msg.state}')
        if msg.state == 1:
            self.bumped = True
            self._logger.info('Bumper pressed, stopping the robot.')

    def wheeldrop_callback(self, msg):
        self._logger.info(f'Wheeldrop event received: {msg.state}')
        if msg.state == 1:
            self.bumped = True
            self._logger.info('Wheeldrop detected, stopping the robot.')

    def button_callback(self, msg):
        self._logger.info(f'Button event received from button: {msg.button} with state: {msg.state}')
        if msg.button == 0 and msg.state == 1:
            self.bumped = False
            self._logger.info('Button released, resuming the robot.')

    def scan_callback(self, scanMsg):
        # Get angle and range info
        angle_min = scanMsg.angle_min
        angle_max = scanMsg.angle_max
        angle_increment = scanMsg.angle_increment
        angle_middle = (angle_min + angle_max) / 2
        
        # Reset the obstacle flags at the start of each scan
        self.obstacle_left = False
        self.obstacle_right = False
        self.obstacle_front = False

        # Iterate over the ranges and classify them based on angle
        for i, dist in enumerate(scanMsg.ranges):
            angle = angle_min + i * angle_increment

            # Ignore invalid ranges (e.g., 0.0 or NaN)
            if dist <= 0.0 or dist == float('inf'):
                continue

            # Check if the obstacle is within 0.1 meters (10 cm) and on the left or right
            if -math.pi/3 <= angle <= -math.pi/8:  # Left side
                if 0.1 < dist < 0.5:
                    self.obstacle_right = True
            elif math.pi/8 <= angle <= math.pi/3:  # Right side
                if 0.1 < dist < 0.5:
                    self.obstacle_left = True
            if -math.pi/8 <= angle <= math.pi/8:  # Front side
                if 0.1 < dist < 0.5:
                    self.obstacle_front = True

        # Log obstacle detection
        """ if self.obstacle_front:
            self._logger.info('Obstacle detected on both sides!')
        elif self.obstacle_left:
            self._logger.info('Obstacle detected on the left!')
        elif self.obstacle_right:
            self._logger.info('Obstacle detected on the right!') """

    def control_callback(self):
        # Create a Twist message
        twist = Twist()

        # Get current position from the robot (odometry)
        try:
            transform = self.tf_buffer.lookup_transform('odom', 'base_link', rclpy.time.Time())
            robot_x = transform.transform.translation.x
            robot_y = transform.transform.translation.y
            robot_theta = self.euler_from_quaternion(transform.transform.rotation)
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException) as e:
            self._logger.warn("Error getting transform: " + str(e))
            return

        # Check if the robot has bumped
        if self.bumped:
            twist.linear.x = 0.0
            twist.angular.z = 0.0
            self._pubVelocity.publish(twist)
            return

        # Calculate the distance and angle to the goal
        dx = self.goal_x - robot_x
        dy = self.goal_y - robot_y
        distance_to_goal = math.sqrt(dx**2 + dy**2)
        angle_to_goal = math.atan2(dy, dx)

        # Calculate the angular difference to the goal direction
        angle_diff = angle_to_goal - robot_theta
        if angle_diff > math.pi:
            angle_diff -= 2 * math.pi
        elif angle_diff < -math.pi:
            angle_diff += 2 * math.pi

        # Movement logic towards the goal
        if not self.obstacle_left and not self.obstacle_right and not self.obstacle_front:
            # No obstacles, move towards the goal
            twist.linear.x = min(self.max_linear_speed, distance_to_goal)
            twist.angular.z = self.angleAccelerate(self.last_angular_z, angle_diff)

            if distance_to_goal < 0.1:  # Stop when the goal is reached
                # Goal reached, publish zero velocities and stop
                self._logger.info('_--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------oal reached!')
                twist.linear.x = 0.0
                twist.angular.z = 0.0
                # After reaching the goal, recheck for the next goal update
                self._pubVelocity.publish(twist)

                return
        else:
            # Handle obstacle avoidance
            if self.obstacle_left and self.obstacle_right:
                twist.linear.x = 0.1
                twist.angular.z = self.max_angular_speed  # Turn right
            elif self.obstacle_left:
                twist.linear.x = 0.1
                twist.angular.z = self.max_angular_speed  # Turn right
            elif self.obstacle_right:
                twist.linear.x = 0.1
                twist.angular.z = -self.max_angular_speed  # Turn left

        # Publish the velocity command
        self._pubVelocity.publish(twist)

        # Update the last velocities
        self.last_linear_x = twist.linear.x
        self.last_angular_z = twist.angular.z


    def accelerate(self, current_value, target_value):
        """Smoothly accelerate or decelerate towards the target value."""
        if current_value < target_value:
            return min(current_value + self.acceleration, target_value)
        elif current_value > target_value:
            return max(current_value - self.decceleration, target_value)
        return current_value

    def angleAccelerate(self, current_value, target_value):
        """Smoothly accelerate or decelerate towards the target value."""
        if current_value < target_value:
            return min(current_value + self.angleAcceleration, target_value)
        elif current_value > target_value:
            return max(current_value - self.angleAcceleration, target_value)
        return current_value

    def euler_from_quaternion(self, quaternion):
        """Convert quaternion to Euler angles."""
        x = quaternion.x
        y = quaternion.y
        z = quaternion.z
        w = quaternion.w
        # Roll, pitch, yaw (ZYX rotation)
        roll = math.atan2(2.0 * (w * x + y * z), 1.0 - 2.0 * (x * x + y * y))
        pitch = math.asin(2.0 * (w * y - z * x))
        yaw = math.atan2(2.0 * (w * z + x * y), 1.0 - 2.0 * (y * y + z * z))
        return yaw  # Only yaw (theta) needed for control


# Go:
if __name__ == '__main__':
    main()
