#!/usr/bin/python3
import sys
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from geometry_msgs.msg import Pose
from nav_msgs.msg import Odometry
from kobuki_ros_interfaces.msg import BumperEvent  # type: ignore
from kobuki_ros_interfaces.msg import WheelDropEvent  # type: ignore
from kobuki_ros_interfaces.msg import ButtonEvent  # type: ignore
from kobuki_ros_interfaces.msg import Sound  # type: ignore
import math
import time


# ROS Node process:
def main():
    # Initialize ROS and a ROS node
    rclpy.init(args=sys.argv)
    node = Node('basic_move')

    # Initialize control class
    control = StraightCtrl(node)  # Pass the node to the constructor

    # Infinite loop for ROS to keep running
    rclpy.spin(node)

    # Clean up
    node.destroy_node()
    rclpy.shutdown()


# ROS Node Class:
class StraightCtrl:
    def __init__(self, rosNode):
        self.rosNode = rosNode  # Store the rosNode instance
        self.obstacle_left = False
        self.obstacle_right = False
        self.bumped = False
        self.highSpeed = False
        self.midSpeed = False
        self.counter = 0
        self.turnRight = False
        self.turnLeft = False
        self.last_linear_x = 0.0  # Track last linear velocity for smooth transition
        self.last_angular_z = 0.0  # Track last angular velocity for smooth transition

        self.max_linear_speed = 0.5  # Max forward speed (m/s)
        self.max_angular_speed = 0.6  # Max angular speed (rad/s)
        self.acceleration = 0.05  # Rate of acceleration
        self.angleAcceleration = 0.2  # Rate of acceleration for angular velocity

        self.current_position = Pose()  # Store the current position of the robot
        self.initializeRosNode()

    def initializeRosNode(self):
        # Initialize subscribers and publishers
        self._subToDetection = self.rosNode.create_subscription(
            String, '/detection',
            self.detection_callback, 10
        )
        
        self._subToOdom = self.rosNode.create_subscription(
            Odometry, '/odom',
            self.odom_callback, 10
        )

        # Get logger from the node:
        self._logger = self.rosNode.get_logger()

        self._subToBumper = self.rosNode.create_subscription(
            BumperEvent, '/events/bumper',
            self.bumper_callback, 10
        )

        self._subToWheeldrop = self.rosNode.create_subscription(
            WheelDropEvent, '/events/wheel_drop',
            self.wheeldrop_callback, 10
        )

        self._subToButtons = self.rosNode.create_subscription(
            ButtonEvent, '/events/button',
            self.button_callback, 10
        )

        self._pubSound = self.rosNode.create_publisher(
            Sound, '/commands/sound',
            10
        )

        self._pubVelocity = self.rosNode.create_publisher(
            Twist, '/multi/cmd_nav', 10
        )

        self._subToScan = self.rosNode.create_subscription(
            LaserScan, '/scan',
            self.scan_callback, 10
        )

        self._timForCtrl = self.rosNode.create_timer(
            0.1, self.control_callback  # Increased time for smoother updates
        )

    def odom_callback(self, msg):
        # Update the current position of the robot from odometry data
        self.current_position = msg.pose.pose

    def detection_callback(self, msg):
        # Log the detection event
        self._logger.info(f'Detection event received: {msg.data}')
        
        # Publish a sound event
        self._pubSound.publish(Sound(value=Sound.CLEANINGEND))
        
        # Log the current position of the robot
        position = self.current_position.position
        self._logger.info(f'Current position: x={position.x:.2f}, y={position.y:.2f}, z={position.z:.2f}')

    def bumper_callback(self, msg):
        self._logger.info(f'Bumper event received: {msg.state}')
        if msg.state == 1:
            self.bumped = True
            self._logger.info('Bumper pressed, stopping the robot.')

    def wheeldrop_callback(self, msg):
        self._logger.info(f'Wheeldrop event received: {msg.state}')
        if msg.state == 1:
            self.bumped = True
            self._logger.info('Wheeldrop detected, stopping the robot.')

    def button_callback(self, msg):
        self._logger.info(f'Button event received from button: {msg.button} with state: {msg.state}')
        if msg.button == 0 and msg.state == 1:
            self.bumped = False
            self._logger.info('Button released, resuming the robot.')

    def scan_callback(self, scanMsg):
        # Process scan data to detect obstacles
        pass

    def control_callback(self):
        # Control logic for the robot
        pass

    def accelerate(self, current_value, target_value):
        # Smoothly accelerate or decelerate
        if current_value < target_value:
            return min(current_value + self.acceleration, target_value)
        elif current_value > target_value:
            return max(current_value - self.acceleration, target_value)
        return current_value

    def angleAccelerate(self, current_value, target_value):
        # Smoothly accelerate or decelerate for angular velocity
        if current_value < target_value:
            return min(current_value + self.angleAcceleration, target_value)
        elif current_value > target_value:
            return max(current_value - self.angleAcceleration, target_value)
        return current_value

# Go:
if __name__ == '__main__':
    main()

