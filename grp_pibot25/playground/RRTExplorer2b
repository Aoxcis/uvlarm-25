#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
import numpy as np
import math
import random

from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose
from visualization_msgs.msg import Marker, MarkerArray

import tf2_ros
from tf2_ros import TransformException
from rclpy.duration import Duration
from scipy.spatial import cKDTree
from collections import deque

class TreeNode:
    def __init__(self, x, y, parent=None):
        self.x = x
        self.y = y
        self.parent = parent

class RRTExplorer(Node):
    def __init__(self):
        super().__init__('rrt_explorer')

        self.map_data = None
        self.map_resolution = 1.0
        self.map_origin_x = 0.0
        self.map_origin_y = 0.0
        self.safety_radius = self.declare_parameter('safety_radius', 1).get_parameter_value().integer_value
        self.step_size = self.declare_parameter('step_size', 10).get_parameter_value().integer_value
        self.min_goal_distance = self.declare_parameter('min_goal_distance', 1.0).get_parameter_value().double_value
        self.cluster_radius = self.declare_parameter('cluster_radius', 5).get_parameter_value().integer_value

        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)

        self.map_sub = self.create_subscription(OccupancyGrid, '/map', self.map_callback, 10)
        self.goal_pub = self.create_publisher(Pose, '/goal', 10)
        self.marker_pub = self.create_publisher(MarkerArray, '/visualization_markers', 10)

        self.timer_period = 5.0
        self.timer = self.create_timer(self.timer_period, self.explore)

        self.robot_cell_x = None
        self.robot_cell_y = None
        self.last_goal = None
        self.frontier_points = []

    def map_callback(self, msg):
        self.map_resolution = msg.info.resolution
        self.map_origin_x = msg.info.origin.position.x
        self.map_origin_y = msg.info.origin.position.y
        self.map_data = np.array(msg.data).reshape(msg.info.height, msg.info.width)

    def explore(self):
        if self.map_data is None:
            self.get_logger().warn("No map data yet.")
            return

        if not self.update_robot_position():
            return

        local_frontiers = self.detect_local_frontiers()
        global_frontiers = self.detect_global_frontiers()

        self.frontier_points = local_frontiers + global_frontiers
        filtered_points = self.filter_frontier_points(self.frontier_points)

        if not filtered_points:
            self.get_logger().info("No valid frontier points found.")
            return

        best_goal = self.select_best_goal(filtered_points)
        self.publish_goal(best_goal.x, best_goal.y)

    def update_robot_position(self):
        try:
            transform_stamped = self.tf_buffer.lookup_transform('map', 'base_link', rclpy.time.Time(), Duration(seconds=0.5))
        except TransformException as ex:
            self.get_logger().warn(f"Could not get transform from map->base_link: {ex}")
            return False

        robot_x_map = transform_stamped.transform.translation.x
        robot_y_map = transform_stamped.transform.translation.y
        self.robot_cell_x = int((robot_x_map - self.map_origin_x) / self.map_resolution)
        self.robot_cell_y = int((robot_y_map - self.map_origin_y) / self.map_resolution)
        return True

    def detect_local_frontiers(self):
        tree = [TreeNode(self.robot_cell_x, self.robot_cell_y)]
        for _ in range(50):
            rx, ry = self.sample_free_space()
            nearest = self.nearest_node(tree, rx, ry)
            new_node = self.steer(nearest, rx, ry)

            if new_node and self.is_free(new_node.x, new_node.y):
                if self.near_unknown(new_node.x, new_node.y):
                    return [new_node]
                tree.append(new_node)
        return []

    def detect_global_frontiers(self):
        tree = [TreeNode(self.robot_cell_x, self.robot_cell_y)]
        frontiers = []
        for _ in range(100):
            rx, ry = self.sample_free_space()
            nearest = self.nearest_node(tree, rx, ry)
            new_node = self.steer(nearest, rx, ry)

            if new_node and self.is_free(new_node.x, new_node.y):
                tree.append(new_node)
                if self.near_unknown(new_node.x, new_node.y):
                    frontiers.append(new_node)
        return frontiers

    def filter_frontier_points(self, points):
        clustered = self.cluster_nodes(points)
        return [max(cluster, key=lambda n: self.information_gain(n)) for cluster in clustered]

    def select_best_goal(self, points):
        return max(points, key=lambda p: self.information_gain(p) - self.navigation_cost(p))

    def sample_free_space(self):
        h, w = self.map_data.shape
        while True:
            rx, ry = random.randint(0, w - 1), random.randint(0, h - 1)
            if self.is_free(rx, ry):
                return rx, ry

    def is_free(self, x, y):
        if not self.is_cell_valid(x, y):
            return False
        return all(self.is_cell_valid(nx, ny) and self.map_data[ny, nx] == 0
                   for nx in range(x - self.safety_radius, x + self.safety_radius + 1)
                   for ny in range(y - self.safety_radius, y + self.safety_radius + 1))

    def is_cell_valid(self, x, y):
        h, w = self.map_data.shape
        return 0 <= x < w and 0 <= y < h

    def steer(self, nearest, rx, ry):
        dx, dy = rx - nearest.x, ry - nearest.y
        dist = math.hypot(dx, dy)
        if dist < self.step_size:
            return TreeNode(rx, ry, nearest)

        theta = math.atan2(dy, dx)
        new_x = int(nearest.x + self.step_size * math.cos(theta))
        new_y = int(nearest.y + self.step_size * math.sin(theta))
        return TreeNode(new_x, new_y, nearest)

    def near_unknown(self, x, y):
        return any(self.is_cell_valid(nx, ny) and self.map_data[ny, nx] == -1
                   for nx in range(x - 1, x + 2)
                   for ny in range(y - 1, y + 2))

    def cluster_nodes(self, nodes):
        positions = [(n.x, n.y) for n in nodes]
        tree = cKDTree(positions)
        clusters = []
        visited = set()

        for i, pos in enumerate(positions):
            if i in visited:
                continue
            neighbors = tree.query_ball_point(pos, self.cluster_radius)
            clusters.append([nodes[j] for j in neighbors])
            visited.update(neighbors)
        return clusters

    def information_gain(self, node):
        radius_cells = int(3 / self.map_resolution)
        gain = sum(1 for nx in range(node.x - radius_cells, node.x + radius_cells + 1)
                   for ny in range(node.y - radius_cells, node.y + radius_cells + 1)
                   if self.is_cell_valid(nx, ny) and self.map_data[ny, nx] == -1)
        return gain

    def navigation_cost(self, node):
        return math.hypot(node.x - self.robot_cell_x, node.y - self.robot_cell_y)

    def publish_goal(self, gx, gy):
        wx = self.map_origin_x + gx * self.map_resolution
        wy = self.map_origin_y + gy * self.map_resolution

        if self.last_goal == (gx, gy):
            self.get_logger().info("Skipping redundant goal.")
            return
        self.last_goal = (gx, gy)

        goal_msg = Pose()
        goal_msg.position.x = wx
        goal_msg.position.y = wy
        goal_msg.orientation.w = 1.0

        self.goal_pub.publish(goal_msg)
        self.get_logger().info(f"Published goal: ({wx:.2f}, {wy:.2f})")

    def nearest_node(self, tree, rx, ry):
        return min(tree, key=lambda node: (node.x - rx)**2 + (node.y - ry)**2)

def main(args=None):
    rclpy.init(args=args)
    node = RRTExplorer()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
