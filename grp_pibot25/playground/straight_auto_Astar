import rclpy
from rclpy.node import Node
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose, Twist
from kobuki_ros_interfaces.msg import BumperEvent, WheelDropEvent, ButtonEvent
import tf2_ros
import math
import numpy as np

class AStarNavigator(Node):
    def __init__(self):
        super().__init__('a_star_navigator')

        self.map_data = None
        self.map_width = 0
        self.map_height = 0
        self.map_resolution = 0.05
        self.map_origin_x = 0.0
        self.map_origin_y = 0.0
        self.occupied_thresh = 50

        # ---------------------------------------------------------------------
        #  Robot / Goal State
        # ---------------------------------------------------------------------
        self.goal_x = None
        self.goal_y = None
        self.bumped = False

        # ---------------------------------------------------------------------
        #  Movement Tuning
        # ---------------------------------------------------------------------
        self.max_lin_speed = 0.3         # (m/s)
        self.max_ang_speed = 1.5         # (rad/s)
        self.lin_accel = 0.1             # (m/s^2)
        self.ang_accel = 0.5             # (rad/s^2)

        self.last_lin_speed = 0.0
        self.last_ang_speed = 0.0

        # Stop if we're within this distance of the goal
        self.goal_reached_dist = 0.05

        # If heading error is larger than this, we reduce forward speed
        self.large_angle_threshold = math.radians(20)

        # ---------------------------------------------------------------------
        #  ROS Setup
        # ---------------------------------------------------------------------
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)

        # Subscriptions
        self.map_sub = self.create_subscription(
            OccupancyGrid, '/map', self.map_callback, 10
        )
        self.goal_sub = self.create_subscription(
            Pose, '/goal', self.goal_callback, 10
        )
        self.bumper_sub = self.create_subscription(
            BumperEvent, '/events/bumper', self.bumper_callback, 10
        )
        self.wheeldrop_sub = self.create_subscription(
            WheelDropEvent, '/events/wheel_drop', self.wheeldrop_callback, 10
        )
        self.button_sub = self.create_subscription(
            ButtonEvent, '/events/button', self.button_callback, 10
        )

        # Publisher for velocity commands
        self.cmd_pub = self.create_publisher(Twist, '/multi/cmd_nav', 10)

        # Timer for control loop
        self.timer = self.create_timer(0.1, self.control_loop)

        self.get_logger().info("AStarNavigator node initialized.")

    def map_callback(self, msg: OccupancyGrid):
        """Store map data for A* planning."""
        self.map_data = np.array(msg.data).reshape(msg.info.height, msg.info.width)
        self.map_width = msg.info.width
        self.map_height = msg.info.height
        self.map_resolution = msg.info.resolution
        self.map_origin_x = msg.info.origin.position.x
        self.map_origin_y = msg.info.origin.position.y
        self.get_logger().info(f"Map received: size = {self.map_width}x{self.map_height}, res={self.map_resolution}")

    def goal_callback(self, msg: Pose):
        """Store goal position and start planning."""
        self.goal_x = msg.position.x
        self.goal_y = msg.position.y
        self.get_logger().info(f"New goal received: x={self.goal_x}, y={self.goal_y}")

    def control_loop(self):
        """Main control loop to follow the path."""
        if self.goal_x is None or self.goal_y is None:
            return

        # Get the robot's current position
        try:
            transform = self.tf_buffer.lookup_transform('map', 'base_link', rclpy.time.Time())
            robot_x = transform.transform.translation.x
            robot_y = transform.transform.translation.y
            robot_theta = self.get_yaw_from_quaternion(transform.transform.rotation)
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException) as e:
            self.get_logger().warn("Error getting transform: " + str(e))
            return

        # Calculate the distance and angle to the goal
        dx = self.goal_x - robot_x
        dy = self.goal_y - robot_y
        distance_to_goal = math.sqrt(dx**2 + dy**2)
        angle_to_goal = math.atan2(dy, dx)

        # Debugging information
        self.get_logger().info(f"Robot position: x={robot_x}, y={robot_y}, theta={robot_theta}")
        self.get_logger().info(f"Goal position: x={self.goal_x}, y={self.goal_y}")
        self.get_logger().info(f"Distance to goal: {distance_to_goal}")

        # Check if the goal is reached
        if distance_to_goal < self.goal_reached_dist:
            self.get_logger().info("Goal reached!")
            self.stop_robot()
            self.goal_x = None
            self.goal_y = None
            return

        # Calculate the angular difference to the goal direction
        angle_diff = angle_to_goal - robot_theta
        if angle_diff > math.pi:
            angle_diff -= 2 * math.pi
        elif angle_diff < -math.pi:
            angle_diff += 2 * math.pi

        twist = Twist()

        # Movement logic towards the goal
        if not self.bumped:
            if abs(angle_diff) > self.large_angle_threshold:
                twist.linear.x = 0.0
                twist.angular.z = self.max_ang_speed if angle_diff > 0 else -self.max_ang_speed
            else:
                twist.linear.x = min(self.max_lin_speed, distance_to_goal)
                twist.angular.z = angle_diff
        else:
            twist.linear.x = 0.0
            twist.angular.z = 0.0

        # Publish the velocity command
        self.cmd_pub.publish(twist)

    def stop_robot(self):
        """Stop the robot by publishing zero velocities."""
        twist = Twist()
        twist.linear.x = 0.0
        twist.angular.z = 0.0
        self.cmd_pub.publish(twist)

    def get_yaw_from_quaternion(self, quaternion):
        """Convert quaternion to yaw angle."""
        x = quaternion.x
        y = quaternion.y
        z = quaternion.z
        w = quaternion.w
        siny_cosp = 2 * (w * z + x * y)
        cosy_cosp = 1 - 2 * (y * y + z * z)
        return math.atan2(siny_cosp, cosy_cosp)

    def bumper_callback(self, msg: BumperEvent):
        """Handle bumper events."""
        if msg.state == BumperEvent.PRESSED:
            self.bumped = True
            self.get_logger().info("Bumper pressed!")
            self.stop_robot()
        else:
            self.bumped = False

    def wheeldrop_callback(self, msg: WheelDropEvent):
        """Handle wheel drop events."""
        if msg.state == WheelDropEvent.DROPPED:
            self.bumped = True
            self.get_logger().info("Wheel dropped!")
            self.stop_robot()
        else:
            self.bumped = False

    def button_callback(self, msg: ButtonEvent):
        """Handle button events."""
        if msg.state == ButtonEvent.PRESSED:
            self.get_logger().info(f"Button {msg.button} pressed!")

def main(args=None):
    rclpy.init(args=args)
    node = AStarNavigator()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()