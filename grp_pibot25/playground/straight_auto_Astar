import rclpy
from rclpy.node import Node
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose, Twist
from sensor_msgs.msg import LaserScan
from kobuki_ros_interfaces.msg import BumperEvent, WheelDropEvent, ButtonEvent, Sound
import tf2_ros
import math

class AStarNavigator(Node):
    def __init__(self):
        super().__init__('a_star_navigator')

        # -------------------------
        #   Map / Cost Data
        # -------------------------
        self.map_data = None
        self.map_width = 0
        self.map_height = 0
        self.map_resolution = 0.05  # will be updated
        self.map_origin_x = 0.0     # will be updated
        self.map_origin_y = 0.0     # will be updated

        # A* parameters
        self.occupied_thresh = 50    # Occupancy >= 50 => considered blocked
        self.motion_8 = True         # Use 8 directions (diagonal moves) or just 4

        # -------------------------
        #   Robot State
        # -------------------------
        self.path = []       # will hold (wx, wy) in world coords
        self.current_path_i = 0
        self.bumped = False

        # -------------------------
        #   Movement Tuning
        # -------------------------
        self.max_lin_speed = 0.3
        self.max_ang_speed = 1.5
        self.lin_accel = 0.1
        self.ang_accel = 0.5
        self.last_lin_speed = 0.0
        self.last_ang_speed = 0.0
        self.goal_reached_dist = 0.05  # Reduced distance threshold

        # -------------------------
        #   ROS Setup
        # -------------------------
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)

        # Subscriptions
        self.create_subscription(OccupancyGrid, '/map', self.map_callback, 10)
        self.create_subscription(Pose, '/goal', self.goal_callback, 10)

        # (Optional) Bumper & button events
        self.create_subscription(BumperEvent, '/events/bumper', self.bumper_callback, 10)
        self.create_subscription(WheelDropEvent, '/events/wheel_drop', self.wheeldrop_callback, 10)
        self.create_subscription(ButtonEvent, '/events/button', self.button_callback, 10)

        # Publisher for velocity commands
        self.cmd_pub = self.create_publisher(Twist, '/multi/cmd_nav', 10)
        
        # (Optional) Sound feedback
        self.sound_pub = self.create_publisher(Sound, '/commands/sound', 10)

        # Timer for control loop
        self.timer = self.create_timer(0.1, self.control_loop)

        self.get_logger().info("AStarNavigator node initialized.")

    # ----------------------------------------------------------------------------
    #   Map & Goal Callbacks
    # ----------------------------------------------------------------------------

    def map_callback(self, msg: OccupancyGrid):
        """Store map data for A* planning."""
        self.map_data = np.array(msg.data).reshape(msg.info.height, msg.info.width)
        self.map_width = msg.info.width
        self.map_height = msg.info.height
        self.map_resolution = msg.info.resolution
        self.map_origin_x = msg.info.origin.position.x
        self.map_origin_y = msg.info.origin.position.y
        self.get_logger().info(f"Map received: size = {self.map_width}x{self.map_height}, res={self.map_resolution}")

    def goal_callback(self, msg: Pose):
        """Store goal position and start planning."""
        self.goal_x = msg.position.x
        self.goal_y = msg.position.y
        self.get_logger().info(f"New goal received: x={self.goal_x}, y={self.goal_y}")
        self.plan_path()

    # ----------------------------------------------------------------------------
    #   Control Loop
    # ----------------------------------------------------------------------------

    def control_loop(self):
        """Main control loop to follow the path."""
        if not self.path:
            return

        # Get the robot's current position
        try:
            transform = self.tf_buffer.lookup_transform('map', 'base_link', rclpy.time.Time())
            robot_x = transform.transform.translation.x
            robot_y = transform.transform.translation.y
            robot_theta = self.get_yaw_from_quaternion(transform.transform.rotation)
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException) as e:
            self.get_logger().warn("Error getting transform: " + str(e))
            return

        # Get the current waypoint
        wx, wy = self.path[self.current_path_i]

        # Calculate the distance and angle to the waypoint
        dx = wx - robot_x
        dy = wy - robot_y
        distance_to_waypoint = math.sqrt(dx**2 + dy**2)
        angle_to_waypoint = math.atan2(dy, dx)

        # Debugging information
        self.get_logger().info(f"Robot position: x={robot_x}, y={robot_y}, theta={robot_theta}")
        self.get_logger().info(f"Waypoint position: x={wx}, y={wy}")
        self.get_logger().info(f"Distance to waypoint: {distance_to_waypoint}")

        # Check if the waypoint is reached
        if distance_to_waypoint < self.goal_reached_dist:
            self.current_path_i += 1
            if self.current_path_i >= len(self.path):
                self.get_logger().info("Goal reached!")
                self.path = []
                self.current_path_i = 0
                self.stop_robot()
                return

        # Calculate the angular difference to the waypoint direction
        angle_diff = angle_to_waypoint - robot_theta
        if angle_diff > math.pi:
            angle_diff -= 2 * math.pi
        elif angle_diff < -math.pi:
            angle_diff += 2 * math.pi

        twist = Twist()

        # Movement logic towards the waypoint
        if not self.bumped:
            twist.linear.x = min(self.max_lin_speed, distance_to_waypoint)
            twist.angular.z = angle_diff
        else:
            twist.linear.x = 0.0
            twist.angular.z = 0.0

        # Publish the velocity command
        self.cmd_pub.publish(twist)

    def stop_robot(self):
        """Stop the robot by publishing zero velocities."""
        twist = Twist()
        twist.linear.x = 0.0
        twist.angular.z = 0.0
        self.cmd_pub.publish(twist)

    def get_yaw_from_quaternion(self, quaternion):
        """Convert quaternion to yaw angle."""
        x = quaternion.x
        y = quaternion.y
        z = quaternion.z
        w = quaternion.w
        siny_cosp = 2 * (w * z + x * y)
        cosy_cosp = 1 - 2 * (y * y + z * z)
        return math.atan2(siny_cosp, cosy_cosp)

    # ----------------------------------------------------------------------------
    #   Bumper & Button Callbacks
    # ----------------------------------------------------------------------------

    def bumper_callback(self, msg: BumperEvent):
        """Handle bumper events."""
        if msg.state == BumperEvent.PRESSED:
            self.bumped = True
            self.get_logger().info("Bumper pressed!")
        else:
            self.bumped = False

    def wheeldrop_callback(self, msg: WheelDropEvent):
        """Handle wheel drop events."""
        if msg.state == WheelDropEvent.DROPPED:
            self.bumped = True
            self.get_logger().info("Wheel dropped!")
        else:
            self.bumped = False

    def button_callback(self, msg: ButtonEvent):
        """Handle button events."""
        if msg.state == ButtonEvent.PRESSED:
            self.get_logger().info(f"Button {msg.button} pressed!")

def main(args=None):
    rclpy.init(args=args)
    node = AStarNavigator()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()